<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>wabi.js - Demo</title>
  <style>
    :root {
      --bg: #f0ede8;
      --text: #2d2a26;
      --accent: #8b7355;
      --card-bg: #fff;
      --border: #e5e0d8;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      text-align: center;
      margin-bottom: 3rem;
    }

    h1 {
      font-size: 3rem;
      margin-bottom: 0.5rem;
      font-weight: 300;
      letter-spacing: -1px;
    }

    h1 span {
      font-weight: 600;
    }

    .tagline {
      color: var(--accent);
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .japanese {
      font-size: 0.9rem;
      color: #999;
    }

    .intro {
      text-align: center;
      max-width: 600px;
      margin: 0 auto 2rem;
      color: #666;
    }

    /* Controls Panel */
    .controls {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }

    .controls h2 {
      margin: 0 0 1rem 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--accent);
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .control-group label {
      font-size: 0.85rem;
      font-weight: 500;
      display: flex;
      justify-content: space-between;
    }

    .control-group label:has(input[type="checkbox"]) {
      justify-content: flex-start;
      gap: 0.5rem;
    }

    .control-group.full-width {
      grid-column: 1 / -1;
    }

    .control-group label span {
      color: var(--accent);
      font-family: monospace;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--border);
      appearance: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: transform 0.1s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .control-group.disabled label {
      opacity: 0.4;
    }

    .control-group.disabled input[type="range"] {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .control-group.disabled input[type="range"]::-webkit-slider-thumb {
      cursor: not-allowed;
    }

    select {
      padding: 0.5rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 0.9rem;
      background: white;
      cursor: pointer;
    }

    .button-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: #7a6548;
    }

    .btn-secondary {
      background: var(--border);
      color: var(--text);
    }

    .btn-secondary:hover {
      background: #d5cfc5;
    }

    /* Demo Sections */
    .demo-section {
      margin-bottom: 3rem;
    }

    .demo-section h3 {
      font-size: 1.1rem;
      margin-bottom: 1rem;
      color: var(--accent);
    }

    /* Cards Demo */
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
    }

    .card {
      background: var(--card-bg);
      padding: 1.5rem;
    }

    .card h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1.1rem;
    }

    .card p {
      margin: 0;
      color: #666;
      font-size: 0.9rem;
    }

    /* Buttons Demo */
    .buttons-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .demo-btn {
      padding: 1rem 2rem;
      font-size: 1rem;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }

    .demo-btn.primary {
      background: var(--accent);
      color: white;
    }

    .demo-btn.secondary {
      background: var(--border);
      color: var(--text);
    }

    .demo-btn.outline {
      background: transparent;
      border: 2px solid var(--accent);
      color: var(--accent);
    }

    /* Images Demo */
    .images-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
    }

    .demo-image {
      width: 100%;
      height: auto;
      display: block;
    }

    /* Boxes Demo */
    .boxes-row {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
    }

    .box {
      width: 100px;
      height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: white;
    }

    .box.red { background: #8B4049; }
    .box.green { background: #C9A876; }
    .box.blue { background: #4A6572; }
    .box.yellow { background: #D4A574; }
    .box.purple { background: #6B4E71; }

    /* Code Display */
    .code-display {
      background: #2d2a26;
      color: #f8f6f3;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 0.85rem;
      overflow-x: auto;
      margin-top: 1rem;
    }

    .code-display .keyword { color: #c9a86b; }
    .code-display .string { color: #8bc96b; }
    .code-display .number { color: #c96b8b; }
    .code-display .comment { color: #888; }

    /* Footer */
    footer {
      text-align: center;
      padding: 2rem;
      color: #999;
      font-size: 0.9rem;
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>wabi<span>.js</span></h1>
      <p class="tagline">侘寂 – because imperfection is beautiful</p>
      <p class="japanese">wabi.js adds small, organic imperfection to your HTML elements using CSS clip-path polygons.</br>
      Adjust the settings below to see the effect in action.</p>
    </header>

    <!-- Controls -->
    <div class="controls">
      <h2>Settings</h2>
      <div class="control-grid">
        <div class="control-group">
          <label>Corner Wobble X <span id="cornerXValue">2.0</span></label>
          <input type="range" id="cornerX" min="0" max="9" step="0.1" value="2">
        </div>
        <div class="control-group">
          <label>Corner Wobble Y <span id="cornerYValue">2.0</span></label>
          <input type="range" id="cornerY" min="0" max="9" step="0.1" value="2">
        </div>
        <div class="control-group">
          <label>Points Per Edge <span id="edgePointsValue">4</span></label>
          <input type="range" id="edgePoints" min="0" max="20" value="2">
        </div>
        <div class="control-group">
          <label>Edge Wobble <span id="edgeWobbleValue">0.8</span></label>
          <input type="range" id="edgeWobble" min="0" max="10" step="0.1" value="0.8">
        </div>
        <div class="control-group">
          <label>Distribution</label>
          <select id="distribution">
            <option value="random">Random</option>
            <option value="even">Even</option>
            <option value="weighted-center">Weighted Center</option>
          </select>
        </div>
        <div class="control-group">
          <label>Seed (0 = random) <span id="seedValue">0</span></label>
          <input type="range" id="seed" min="0" max="1000" value="0">
        </div>
        <div class="control-group">
          <label>Cut Corners <span id="cutCornersValue">0</span></label>
          <input type="range" id="cutCorners" min="0" max="4" value="0">
        </div>
        <div class="control-group cut-corner-chamfer-control">
          <label>Cut Corner Chamfer <span id="cutCornerChamferValue">1.0</span></label>
          <input type="range" id="cornerChamfer" min="0" max="1" step="0.1" value="1">
        </div>
        <div class="control-group full-width">
          <label>
            <input type="checkbox" id="animateEnabled"> Enable Animation
          </label>
        </div>
        <div class="control-group animate-control" style="display: none;">
          <label>Animation Interval <span id="animateIntervalValue">100</span>ms</label>
          <input type="range" id="animateInterval" min="20" max="500" step="10" value="100">
        </div>
        <div class="control-group full-width">
          <label>
            <input type="checkbox" id="shadowEnabled"> Enable Shadow
          </label>
        </div>
        <div class="control-group shadow-control" style="display: none;">
          <label>Shadow X <span id="shadowXValue">-10</span></label>
          <input type="range" id="shadowX" min="-20" max="20" value="-10">
        </div>
        <div class="control-group shadow-control" style="display: none;">
          <label>Shadow Y <span id="shadowYValue">10</span></label>
          <input type="range" id="shadowY" min="-20" max="20" value="10">
        </div>
        <div class="control-group shadow-control" style="display: none;">
          <label>Shadow Blur <span id="shadowBlurValue">10</span></label>
          <input type="range" id="shadowBlur" min="0" max="30" value="8">
        </div>
        <div class="control-group shadow-control" style="display: none;">
          <label>Shadow Color</label>
          <input type="color" id="shadowColor" value="#000000">
        </div>
      </div>
      <div class="button-row">
        <button class="btn btn-primary" id="randomizeBtn">Randomize</button>
        <button class="btn btn-secondary" id="resetBtn">Reset</button>
      </div>
      <div class="code-display" id="codePreview">
        <span class="keyword">wabi</span>(<span class="string">'.demo'</span>, { corners: { x: <span class="number">5</span>, y: <span class="number">4</span> } });
      </div>
    </div>

    <!-- Demo: Cards -->
    <section class="demo-section">
      <h3>Cards</h3>
      <div class="cards-grid">
        <div class="card demo">
          <h4>Imperfect Design</h4>
          <p>The eye gets tired on perfection.</p>
        </div>
        <div class="card demo">
          <h4>No rounded corners</h4>
          <p>Enough with the 2015 aesthetic already!</p>
        </div>
        <div class="card demo">
          <h4>Clip-Path Performance</h4>
          <p>Uses CSS clip-path polygon for GPU-accelerated effects.</p>
        </div>
      </div>
    </section>

    <!-- Demo: Buttons -->
    <section class="demo-section">
      <h3>Buttons</h3>
      <div class="buttons-row">
        <button class="demo-btn primary demo">Primary</button>
        <button class="demo-btn secondary demo">Secondary</button>
        <button class="demo-btn outline demo">Outline</button>
      </div>
    </section>

    <!-- Demo: Images -->
    <section class="demo-section">
      <h3>Images</h3>
      <div class="images-grid">
        <img src="circles.jpg" alt="Circles" class="demo-image demo">
        <img src="plant.jpg" alt="Eco" class="demo-image demo">
        <img src="mampf.jpg" alt="Mampf" class="demo-image demo">
      </div>
    </section>

    <!-- Demo: Colored Boxes -->
    <section class="demo-section">
      <h3>Colored Boxes</h3>
      <div class="boxes-row">
        <div class="box red demo">1</div>
        <div class="box green demo">2</div>
        <div class="box blue demo">3</div>
        <div class="box yellow demo">4</div>
        <div class="box purple demo">5</div>
      </div>
    </section>


    <!-- Integration Guide -->
    <section class="demo-section">
      <h3>How to Use</h3>
      <div class="card" style="max-width: 800px;">
        <h4 style="margin-top: 1.5rem;">0. Get wabi.js</h4>
        <p>Go to the <a href="https://github.com/rybi/wabi.js">wabi.js GitHub repository</a> and download the latest release.</p>
  

        <h4 style="margin-top: 1.5rem;">1. Add the script to your page</h4>
        <p>Download <code>wabi.min.js</code> from the dist folder and include it in your HTML:</p>
        <div class="code-display">
&lt;script src="wabi.min.js"&gt;&lt;/script&gt;
        </div>

        <h4 style="margin-top: 1.5rem;">2. Call wabi() on your elements</h4>
        <p>Add this script before the closing <code>&lt;/body&gt;</code> tag. The effect is applied when the page loads:</p>
        <div class="code-display">
&lt;script&gt;
  window.addEventListener(<span class="string">'load'</span>, <span class="keyword">function</span>() {<br>
    <span class="keyword">wabi</span>(<span class="string">'.my-cards'</span>, {
      corners: { x: <span class="number">5</span>, y: <span class="number">4</span> }
    });<br>
        <span class="comment">//You can apply different settings to different elements by calling wabi() multiple times:</span><br>

        <span class="keyword">wabi</span>(<span class="string">'.buttons'</span>, {
      corners: { x: <span class="number">2</span>, y: <span class="number">2</span> },
      animate: <span class="keyword">true</span>
  });<br>
&lt;/script&gt;
        </div>

        <h4 style="margin-top: 1.5rem;">3. That's it!</h4>
        <p>The library works by applying a CSS <code>clip-path</code> polygon to your elements. No dependencies, no build step required.</p>

        <h4 style="margin-top: 1.5rem;">Settings reference</h4>
        <ul style="margin: 0.5rem 0; padding-left: 1.5rem; color: #666; font-size: 0.9rem;">
          <li><code>corners.x</code> / <code>corners.y</code> — Maximum random displacement of corners in each direction (as % of element size).</li>
          <li><code>edges.points</code> — Number of additional points to add along each edge between corners.</li>
          <li><code>edges.edgeWobble</code> — How far edge points can deviate perpendicular to the edge line.</li>
          <li><code>edges.distribution</code> — How edge points are spaced: <code>'random'</code>, <code>'even'</code>, or <code>'weighted-center'</code>.</li>
          <li><code>seed</code> — Fixed seed for reproducible randomness; use <code>null</code> for different results each time.</li>
          <li><code>cutCorners</code> — Number of corners (0-4) to randomly cut off, creating angled shapes.</li>
          <li><code>cornerChamfer</code> — How far cut corners move inward (0 = no change, 1 = full cut).</li>
        </ul>

        <h4 style="margin-top: 1.5rem;">Using with ES modules</h4>
        <p>If you're using a bundler or ES modules:</p>
        <div class="code-display">
<span class="keyword">import</span> wabi <span class="keyword">from</span> <span class="string">'./wabi.esm.js'</span>;<br>
<br>
<span class="keyword">wabi</span>(<span class="string">'#myElement'</span>, { corners: { x: <span class="number">3</span>, y: <span class="number">3</span> } });
        </div>

        <h4 style="margin-top: 1.5rem;">Restoring elements</h4>
        <p>The function returns an object with a <code>restore()</code> method:</p>
        <div class="code-display">
&lt;script&gt;
  window.addEventListener(<span class="string">'load'</span>, <span class="keyword">function</span>() {<br>
    <span class="keyword">var</span> result = <span class="keyword">wabi</span>(<span class="string">'.cards'</span>, { corners: { x: <span class="number">5</span>, y: <span class="number">5</span> } });<br>
<br>
    <span class="comment">// Later, remove the effect:</span><br>
    result.<span class="keyword">restore</span>();<br>
  });
&lt;/script&gt;
        </div>

        <h4 style="margin-top: 1.5rem;">Animating elements</h4>
        <p>Continuously randomize the shape at a given interval:</p>
        <div class="code-display">
&lt;script&gt;
  window.addEventListener(<span class="string">'load'</span>, <span class="keyword">function</span>() {<br>
    <span class="keyword">var</span> result = <span class="keyword">wabi</span>(<span class="string">'.cards'</span>, { corners: { x: <span class="number">5</span>, y: <span class="number">5</span> } });<br>
<br>
    <span class="comment">// Start animation (default: 100ms interval)</span><br>
    result.<span class="keyword">animate</span>();<br>

    <span class="comment">// Or with custom interval</span><br>
    result.<span class="keyword">animate</span>({ interval: <span class="number">200</span> });<br>

    <span class="comment">// Stop animation</span><br>
    result.<span class="keyword">stop</span>();<br>

    <span class="comment">// Check if animating</span><br>
    result.isAnimating; <span class="comment">// true or false</span><br>
  });
&lt;/script&gt;
        </div>
        <p style="margin-top: 0.5rem; color: #666; font-size: 0.9rem;">You can also auto-start animation via options: <code>wabi('.cards', { animate: true })</code> or <code>{ animate: { interval: 200 } }</code></p>
      </div>
    </section>

    <footer>
      <p>
        <a href="https://github.com/rybi/wabi.js" target="_blank">GitHub</a> ·
        Made by <a href="https://rybakov.com/" target="_blank">Michail Rybakov</a> for <a href="https://gradient.horse/" target="_blank">gradient.horse</a>
      </p>
    </footer>
  </div>

  <script type="module">
    import wabi from './dist/wabi.esm.js';

    // State
    let currentResult = null;

    // DOM Elements
    const controls = {
      cornerX: document.getElementById('cornerX'),
      cornerY: document.getElementById('cornerY'),
      edgePoints: document.getElementById('edgePoints'),
      edgeWobble: document.getElementById('edgeWobble'),
      distribution: document.getElementById('distribution'),
      seed: document.getElementById('seed'),
      cutCorners: document.getElementById('cutCorners'),
      cutCornerChamfer: document.getElementById('cornerChamfer'),
      animateEnabled: document.getElementById('animateEnabled'),
      animateInterval: document.getElementById('animateInterval'),
      shadowEnabled: document.getElementById('shadowEnabled'),
      shadowX: document.getElementById('shadowX'),
      shadowY: document.getElementById('shadowY'),
      shadowBlur: document.getElementById('shadowBlur'),
      shadowColor: document.getElementById('shadowColor'),
    };

    const values = {
      cornerX: document.getElementById('cornerXValue'),
      cornerY: document.getElementById('cornerYValue'),
      edgePoints: document.getElementById('edgePointsValue'),
      edgeWobble: document.getElementById('edgeWobbleValue'),
      seed: document.getElementById('seedValue'),
      cutCorners: document.getElementById('cutCornersValue'),
      cutCornerChamfer: document.getElementById('cutCornerChamferValue'),
      animateInterval: document.getElementById('animateIntervalValue'),
      shadowX: document.getElementById('shadowXValue'),
      shadowY: document.getElementById('shadowYValue'),
      shadowBlur: document.getElementById('shadowBlurValue'),
    };

    const codePreview = document.getElementById('codePreview');

    // Animation controls visibility
    const animateControls = document.querySelectorAll('.animate-control');
    function updateAnimateControlsVisibility() {
      const display = controls.animateEnabled.checked ? 'flex' : 'none';
      animateControls.forEach(el => el.style.display = display);
    }
    controls.animateEnabled.addEventListener('change', updateAnimateControlsVisibility);

    // Shadow controls visibility
    const shadowControls = document.querySelectorAll('.shadow-control');
    function updateShadowControlsVisibility() {
      const display = controls.shadowEnabled.checked ? 'flex' : 'none';
      shadowControls.forEach(el => el.style.display = display);
    }
    controls.shadowEnabled.addEventListener('change', updateShadowControlsVisibility);

    // Cut corner chamfer control disabled state (disable when cutCorners = 0)
    const cutCornerChamferControl = document.querySelector('.cut-corner-chamfer-control');
    function updateCutCornerChamferState() {
      const disabled = parseInt(controls.cutCorners.value) === 0;
      cutCornerChamferControl.classList.toggle('disabled', disabled);
      controls.cutCornerChamfer.disabled = disabled;
    }
    controls.cutCorners.addEventListener('input', updateCutCornerChamferState);
    updateCutCornerChamferState();

    // Get current options from controls
    function getOptions() {
      const seedVal = parseInt(controls.seed.value);
      const cutCornersVal = parseInt(controls.cutCorners.value);
      const cutCornerChamferVal = parseFloat(controls.cutCornerChamfer.value);
      const opts = {
        corners: {
          x: parseFloat(controls.cornerX.value),
          y: parseFloat(controls.cornerY.value),
        },
        edges: {
          points: parseInt(controls.edgePoints.value),
          edgeWobble: parseFloat(controls.edgeWobble.value),
          distribution: controls.distribution.value,
        },
        cutCorners: cutCornersVal,
        cornerChamfer: cutCornerChamferVal,
        seed: seedVal === 0 ? null : seedVal,
      };

      // Add shadow if enabled
      if (controls.shadowEnabled.checked) {
        // Convert hex color to rgba with 0.3 opacity
        const hex = controls.shadowColor.value;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        opts.shadow = {
          x: parseInt(controls.shadowX.value),
          y: parseInt(controls.shadowY.value),
          blur: parseInt(controls.shadowBlur.value),
          color: `rgba(${r},${g},${b},0.3)`,
        };
      }

      return opts;
    }

    // Update code preview
    function updateCodePreview() {
      const opts = getOptions();
      let code = `<span class="keyword">wabi</span>(<span class="string">'.demo'</span>, {\n`;
      code += `  corners: { x: <span class="number">${opts.corners.x}</span>, y: <span class="number">${opts.corners.y}</span> }`;

      if (opts.edges.points > 0) {
        code += `,\n  edges: { points: <span class="number">${opts.edges.points}</span>, edgeWobble: <span class="number">${opts.edges.edgeWobble}</span>, distribution: <span class="string">'${opts.edges.distribution}'</span> }`;
      }

      if (opts.cutCorners > 0) {
        code += `,\n  cutCorners: <span class="number">${opts.cutCorners}</span>`;
        if (opts.cornerChamfer < 1) {
          code += `,\n  cornerChamfer: <span class="number">${opts.cornerChamfer}</span>`;
        }
      }

      if (opts.shadow) {
        code += `,\n  shadow: { x: <span class="number">${opts.shadow.x}</span>, y: <span class="number">${opts.shadow.y}</span>, blur: <span class="number">${opts.shadow.blur}</span>, color: <span class="string">'${opts.shadow.color}'</span> }`;
      }

      if (opts.seed !== null) {
        code += `,\n  seed: <span class="number">${opts.seed}</span>`;
      }

      if (controls.animateEnabled.checked) {
        const interval = parseInt(controls.animateInterval.value);
        code += `,\n  animate: { interval: <span class="number">${interval}</span> }`;
      }

      code += `\n});`;
      codePreview.innerHTML = code;
    }

    // Update value displays
    function updateValueDisplays() {
      values.cornerX.textContent = parseFloat(controls.cornerX.value).toFixed(1);
      values.cornerY.textContent = parseFloat(controls.cornerY.value).toFixed(1);
      values.edgePoints.textContent = controls.edgePoints.value;
      values.edgeWobble.textContent = parseFloat(controls.edgeWobble.value).toFixed(1);
      values.seed.textContent = controls.seed.value;
      values.cutCorners.textContent = controls.cutCorners.value;
      values.cutCornerChamfer.textContent = parseFloat(controls.cutCornerChamfer.value).toFixed(1);
      values.animateInterval.textContent = controls.animateInterval.value;
      values.shadowX.textContent = controls.shadowX.value;
      values.shadowY.textContent = controls.shadowY.value;
      values.shadowBlur.textContent = controls.shadowBlur.value;
    }

    // Apply wabi effect
    function applyEffect() {
      // Restore previous if exists
      if (currentResult) {
        currentResult.restore();
      }

      const options = getOptions();
      currentResult = wabi('.demo', options);

      // Start animation if enabled
      if (controls.animateEnabled.checked) {
        const interval = parseInt(controls.animateInterval.value);
        currentResult.animate({ interval });
      }

      updateCodePreview();
    }

    // Randomize values
    function randomize() {
      controls.cornerX.value = Math.floor(Math.random() * 15) + 1;
      controls.cornerY.value = Math.floor(Math.random() * 15) + 1;
      controls.edgePoints.value = Math.floor(Math.random() * 19) + 2;
      controls.edgeWobble.value = Math.floor(Math.random() * 8) + 1;
      controls.distribution.value = ['random', 'even', 'weighted-center'][Math.floor(Math.random() * 3)];
      controls.seed.value = 0;
      controls.cutCorners.value = Math.floor(Math.random() * 3); // 0-2 corners
      controls.cutCornerChamfer.value = (Math.random() * 0.8 + 0.2).toFixed(1); // 0.2-1.0
      updateCutCornerChamferState();
      updateValueDisplays();
      applyEffect();
    }

    // Reset to defaults
    function reset() {
      controls.cornerX.value = 2;
      controls.cornerY.value = 2;
      controls.edgePoints.value = 2;
      controls.edgeWobble.value = 0.8;
      controls.distribution.value = 'random';
      controls.seed.value = 0;
      controls.cutCorners.value = 0;
      controls.cutCornerChamfer.value = 1;
      controls.animateEnabled.checked = false;
      controls.animateInterval.value = 100;
      controls.shadowEnabled.checked = false;
      controls.shadowX.value = -10;
      controls.shadowY.value = 10;
      controls.shadowBlur.value = 8;
      controls.shadowColor.value = '#000000';
      updateAnimateControlsVisibility();
      updateShadowControlsVisibility();
      updateCutCornerChamferState();
      updateValueDisplays();
      applyEffect();
    }

    // Event Listeners - auto-apply on any change
    Object.values(controls).forEach(control => {
      control.addEventListener('input', () => {
        updateValueDisplays();
        applyEffect();
      });
      // Also handle change for checkbox
      control.addEventListener('change', () => {
        updateValueDisplays();
        applyEffect();
      });
    });

    document.getElementById('randomizeBtn').addEventListener('click', randomize);
    document.getElementById('resetBtn').addEventListener('click', reset);

    // Initial apply
    applyEffect();
  </script>
</body>
</html>
